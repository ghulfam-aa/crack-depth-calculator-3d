<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crack Depth Calculator (3D - Final Attempt)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* CSS remains identical to the previous full 3D version */
        :root {
            --primary-color: #3498db; --primary-dark: #2980b9; --secondary-color: #e0f2fe;
            --text-dark: #2c3e50; --text-light: #5a6878; --border-color: #cbd5e0;
            --background-light: #ffffff; --background-gradient-start: #eaf0f7; --background-gradient-end: #d8e2ec;
            --success-bg: #e0f2fe; --success-border: #a0cff5; --success-icon: #3498db;
            --error-bg: #feefec; --error-border: #f5a0a4; --error-icon: #e74c3c;
            --diagram-concrete: #e2e8f0; --diagram-transducer: #374151;
            --diagram-crack: #e74c3c; --diagram-label: #4b5563;
        }
         * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
         body { background: linear-gradient(135deg, var(--background-gradient-start), var(--background-gradient-end)); min-height: 100vh; display: flex; justify-content: center; align-items: center; padding: 20px; font-size: 16px; color: var(--text-dark); }
        .container { background: var(--background-light); border-radius: 15px; box-shadow: 0 15px 35px rgba(44, 62, 80, 0.15); padding: 40px; width: 100%; max-width: 500px; transition: transform 0.3s ease, box-shadow 0.3s ease; border: 1px solid #e2e8f0; }
        .container:hover { transform: translateY(-5px); box-shadow: 0 20px 40px rgba(44, 62, 80, 0.2); }
        h1 { text-align: center; color: var(--text-dark); margin-bottom: 35px; font-size: 26px; font-weight: 600; letter-spacing: 0.5px; }
        h1 i { margin-right: 10px; color: var(--primary-color); }
        .input-group { margin-bottom: 25px; }
        label { display: block; color: var(--text-light); font-size: 14px; margin-bottom: 8px; font-weight: 500; }
        input[type="number"] { width: 100%; padding: 12px 15px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; transition: border-color 0.3s ease, box-shadow 0.3s ease; appearance: textfield; -moz-appearance: textfield; }
        input[type=number]::-webkit-outer-spin-button, input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        input:focus { border-color: var(--primary-color); outline: none; box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2); }
        /* Ensure button selector is specific if needed */
        #calculateButton { width: 100%; padding: 14px; background: linear-gradient(180deg, var(--primary-color), var(--primary-dark)); border: none; border-radius: 8px; color: #fff; font-size: 16px; font-weight: 600; cursor: pointer; transition: background 0.3s ease, transform 0.1s ease, box-shadow 0.3s ease; box-shadow: 0 4px 6px rgba(50, 50, 93, 0.11), 0 1px 3px rgba(0, 0, 0, 0.08); }
        #calculateButton:hover { background: linear-gradient(180deg, #4fa8e0, #318fd6); box-shadow: 0 7px 14px rgba(50, 50, 93, 0.1), 0 3px 6px rgba(0, 0, 0, 0.08); }
        #calculateButton:active { transform: translateY(1px); }
        #result { margin-top: 30px; font-size: 16px; padding: 15px 20px; border-radius: 8px; display: flex; align-items: center; justify-content: flex-start; min-height: 58px; width: 100%; line-height: 1.5; word-wrap: break-word; transition: background-color 0.3s ease, border-color 0.3s ease; background-color: var(--success-bg); border: 1px solid var(--success-border); color: var(--text-dark); }
        #result i { font-size: 20px; margin-right: 12px; color: var(--success-icon); flex-shrink: 0; }
        #result.error { background-color: var(--error-bg); border-color: var(--error-border); color: #a54844; }
        #result.error i { color: var(--error-icon); }
        .footer { text-align: center; margin-top: 30px; font-size: 12px; color: var(--text-light); }
        #diagramSection { margin-top: 30px; padding-top: 20px; border-top: 1px solid var(--border-color); display: none; position: relative; }
        #diagramSection h2 { font-size: 16px; font-weight: 600; color: var(--text-dark); margin-bottom: 15px; text-align: center; }
        #diagramCanvas { display: block; width: 100% !important; max-width: 400px; height: 250px !important; margin: 0 auto; background-color: #f8fafd; border-radius: 5px; cursor: grab; }
        #diagramCanvas:active { cursor: grabbing; }
        .diagram-label-3d { position: absolute; font-size: 10px; font-weight: 500; color: var(--diagram-label); background-color: rgba(255, 255, 255, 0.85); padding: 2px 4px; border-radius: 3px; white-space: nowrap; text-align: center; pointer-events: none; transform: translateX(-50%); display: none; }
        @media (max-width: 480px) { #diagramCanvas { height: 200px !important; } .diagram-label-3d { font-size: 9px; } }
    </style>
</head>
<body>
    <div class="container">
        <h1><i class="fas fa-ruler-combined"></i>Crack Depth Calculator (3D)</h1>
        <!-- Using onsubmit="return false;" as backup -->
        <form id="crackForm" onsubmit="return false;">
             <div class="input-group"><label for="t1">Transit Time (t1, µs):</label><input type="number" id="t1" step="any" min="0.00001" required placeholder="e.g., 25"></div>
             <div class="input-group"><label for="l1">Sound Spacing (L1, mm):</label><input type="number" id="l1" step="any" min="0.00001" required placeholder="e.g., 100"></div>
             <div class="input-group"><label for="t2">Crack Time (t2, µs):</label><input type="number" id="t2" step="any" min="0.00001" required placeholder="e.g., 70.7"></div>
             <div class="input-group"><label for="l2">Crack Spacing (L2, mm):</label><input type="number" id="l2" step="any" min="0.00001" required placeholder="e.g., 200"></div>
             <!-- Button needs the ID -->
             <button type="submit" id="calculateButton">Calculate Crack Depth</button>
        </form>

        <div id="result"><i class="fas fa-info-circle"></i><span>Result will appear here</span></div>

        <div id="diagramSection">
            <h2>3D Schematic View</h2>
            <canvas id="diagramCanvas"></canvas>
            <span id="label-l2-start" class="diagram-label-3d">0 mm</span>
            <span id="label-l2-end" class="diagram-label-3d">L2 = ? mm</span>
            <span id="label-h-value" class="diagram-label-3d">h = ? mm</span>
        </div>

        <div class="footer">Powered by PULSONIC | Based on BS EN 12504-4:2004 | 3D View: Three.js</div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.161.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/" } }
    </script>

    <script type="module">
        // Strict mode helps catch common errors
        "use strict";

        // Imports
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Module scope variables ---
        // DOM Elements
        let form, calculateButton, resultDiv, resultIcon, resultText;
        let diagramSection, diagramCanvas;
        let labelL2Start, labelL2End, labelHValue;
        // Three.js variables
        let scene, camera, renderer, controls;
        let concreteBlock, crackPlane, transducerLeft, transducerRight;
        let threeJsInitialized = false; // Flag to track initialization

        // Constants
        const VISUAL_WIDTH_SCALE = 5; const VISUAL_DEPTH_SCALE = 3; const CRACK_PLANE_WIDTH = 0.1;

        // --- Function Definitions ---

        // Show/Update Result Area
        function showResult(message, isError = false) {
            if (!resultDiv || !resultIcon || !resultText) {
                 console.error("Result elements not found in showResult");
                 return;
            }
            console.log(`ShowResult: "${message}", Error: ${isError}`);
            resultText.textContent = message;
            if (isError) {
                resultDiv.classList.add('error');
                resultIcon.className = "fas fa-exclamation-triangle";
                if (diagramSection) diagramSection.style.display = 'none'; // Hide diagram on error
                if (labelL2Start) labelL2Start.style.display = 'none';
                if (labelL2End) labelL2End.style.display = 'none';
                if (labelHValue) labelHValue.style.display = 'none';
            } else {
                resultDiv.classList.remove('error');
                resultIcon.className = "fas fa-check-circle";
                // Diagram display handled by caller on success
            }
        }

        // Calculation Logic
        function calculateCrackDepth() {
            console.log("CalculateCrackDepth function started.");
            // Get inputs (assuming elements are globally available or passed in)
            const t1Input = document.getElementById('t1'); const l1Input = document.getElementById('l1');
            const t2Input = document.getElementById('t2'); const l2Input = document.getElementById('l2');

            // Check if inputs exist before accessing .value
            if (!t1Input || !l1Input || !t2Input || !l2Input) {
                showResult("Error: Input fields missing.", true);
                console.error("Input field elements missing.");
                return; // Stop calculation
            }

            const t1 = parseFloat(t1Input.value); const l1 = parseFloat(l1Input.value);
            const t2 = parseFloat(t2Input.value); const l2 = parseFloat(l2Input.value);
            console.log(`Parsed Inputs: t1=${t1}, l1=${l1}, t2=${t2}, l2=${l2}`);

            // --- Validation ---
            if (isNaN(t1) || isNaN(l1) || isNaN(t2) || isNaN(l2)) { showResult("Error: All inputs must be valid numbers.", true); return; }
            if (t1 <= 0 || l1 <= 0 || t2 <= 0 || l2 <= 0) { showResult("Error: All values must be greater than zero.", true); return; }

            const velocity = l1 / t1;
            if (!isFinite(velocity) || velocity <= 0) { showResult("Error: Cannot calculate velocity. Check t1 and l1.", true); return; }
            console.log(`Calculated Velocity: ${velocity}`);

            const t1Scaled = l2 / velocity;
            console.log(`Calculated t1_scaled: ${t1Scaled}`);
            const a = l2 / 2; const ratio = t2 / t1Scaled;

             if (ratio <= 1 || !isFinite(ratio)) {
                const errorDetail = isFinite(t1Scaled) ? `(t2/t1_scaled ratio: ${ratio.toFixed(3)})` : '(Invalid t1_scaled)';
                showResult(`Error: t2 must be > calculated direct time. ${errorDetail}`, true); return;
             }

            const h = a * Math.sqrt(ratio * ratio - 1);
            console.log(`Calculated Depth h: ${h}`);
            if (!isFinite(h)) { showResult("Error: Calculation resulted in an invalid depth.", true); return; }

            // --- Success ---
            showResult(`Crack Depth: ${h.toFixed(2)} mm`, false);

            // --- Update 3D (if initialized) ---
            if (threeJsInitialized && diagramSection) {
                 console.log("Attempting to update 3D diagram...");
                 diagramSection.style.display = 'block'; // Show the section
                 try {
                     updateDiagram3D(l2, h);
                     console.log("3D diagram updated successfully.");
                 } catch (error) {
                     console.error("Error updating 3D diagram:", error);
                     showResult(`Crack Depth: ${h.toFixed(2)} mm. (Error updating 3D view)`, false); // Show result but note error
                 }
            } else {
                 console.log("Skipping 3D update (not initialized or section not found).");
            }
            console.log("CalculateCrackDepth function finished.");
        }


        // --- Three.js Functions (Identical logic, ensure called correctly) ---
        function initThreeJS() {
            console.log("Attempting to initialize Three.js...");
            try {
                diagramCanvas = document.getElementById('diagramCanvas');
                if (!diagramCanvas) throw new Error("Canvas element 'diagramCanvas' not found!");

                labelL2Start = document.getElementById('label-l2-start');
                labelL2End = document.getElementById('label-l2-end');
                labelHValue = document.getElementById('label-h-value');
                if (!labelL2Start || !labelL2End || !labelHValue) console.warn("One or more 3D labels not found.");

                scene = new THREE.Scene(); scene.background = new THREE.Color(0xf0f4f8);
                const aspectRatio = diagramCanvas.clientWidth / diagramCanvas.clientHeight;
                camera = new THREE.PerspectiveCamera(50, aspectRatio, 0.1, 100); camera.position.set(0, 3, 8); camera.lookAt(0, 0, 0);
                renderer = new THREE.WebGLRenderer({ canvas: diagramCanvas, antialias: true, alpha: true }); // Added alpha
                renderer.setSize(diagramCanvas.clientWidth, diagramCanvas.clientHeight); renderer.setPixelRatio(window.devicePixelRatio);
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(5, 10, 7.5); scene.add(directionalLight);
                controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.1; controls.screenSpacePanning = false; controls.target.set(0, 0, 0);

                createInitialObjects(); // Create the meshes
                animate(); // Start the render loop
                window.addEventListener('resize', onWindowResize, false);
                threeJsInitialized = true; // Set flag
                console.log("Three.js Initialized Successfully.");

            } catch (error) {
                 console.error("!!! Three.js Initialization Failed:", error);
                 threeJsInitialized = false;
                 showResult("Error initializing 3D view. Calculator might still work.", true);
                 // Optionally hide the diagram section if init fails
                 if(diagramSection) diagramSection.style.display = 'none';
            }
        }
        function createInitialObjects() { /* Identical */
            const blockGeometry = new THREE.BoxGeometry(VISUAL_WIDTH_SCALE * 1.2, VISUAL_DEPTH_SCALE, VISUAL_DEPTH_SCALE * 0.8);
            const blockMaterial = new THREE.MeshStandardMaterial({ color: 0xd1d5db, roughness: 0.8 });
            concreteBlock = new THREE.Mesh(blockGeometry, blockMaterial); concreteBlock.position.y = -VISUAL_DEPTH_SCALE / 2; scene.add(concreteBlock);
            const transducerRadius = 0.15; const transducerHeight = 0.1; const transducerGeometry = new THREE.CylinderGeometry(transducerRadius, transducerRadius, transducerHeight, 16);
            const transducerMaterial = new THREE.MeshStandardMaterial({ color: 0x374151, roughness: 0.5 });
            transducerLeft = new THREE.Mesh(transducerGeometry, transducerMaterial); transducerLeft.position.set(-VISUAL_WIDTH_SCALE / 2, transducerHeight / 2, 0); scene.add(transducerLeft);
            transducerRight = new THREE.Mesh(transducerGeometry, transducerMaterial); transducerRight.position.set(VISUAL_WIDTH_SCALE / 2, transducerHeight / 2, 0); scene.add(transducerRight);
            const crackGeometry = new THREE.PlaneGeometry(CRACK_PLANE_WIDTH, 0.01);
            const crackMaterial = new THREE.MeshBasicMaterial({ color: 0xef4444, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
            crackPlane = new THREE.Mesh(crackGeometry, crackMaterial); crackPlane.position.set(0, -0.005, 0); scene.add(crackPlane);
            console.log("Initial 3D objects created.");
        }
        function updateDiagram3D(l2, h) { /* Identical logic */
            if (!threeJsInitialized || !transducerLeft || !transducerRight || !crackPlane) return; // Safety check
            const visualL2 = VISUAL_WIDTH_SCALE; transducerLeft.position.x = -visualL2 / 2; transducerRight.position.x = visualL2 / 2;
            const maxExpectedH = l2 > 0 ? l2 : 1; const visualMaxH = VISUAL_DEPTH_SCALE * 0.9;
            const h_scaled = (h / maxExpectedH) * visualMaxH;
            const finalVisualH = Math.min(Math.max(h_scaled, 0.01), visualMaxH);
            crackPlane.scale.y = finalVisualH / 0.01; crackPlane.position.y = - (finalVisualH / 2);
            updateOverlayLabels(l2, h);
        }
        function updateOverlayLabels(l2, h) { /* Identical logic with safety checks */
             if (!renderer || !camera || !labelL2Start || !labelL2End || !labelHValue || !transducerLeft || !transducerRight || !crackPlane) return;
             const canvas = renderer.domElement;
             const toScreenPosition = (object) => {
                 const vector = new THREE.Vector3(); object.getWorldPosition(vector); vector.project(camera);
                 const x = ((vector.x * 0.5 + 0.5) * canvas.clientWidth); const y = ((-vector.y * 0.5 + 0.5) * canvas.clientHeight); return { x, y };
             };
             try {
                 const posL2Start = toScreenPosition(transducerLeft); const posL2End = toScreenPosition(transducerRight);
                 const crackTopPos = new THREE.Vector3(crackPlane.position.x, 0, crackPlane.position.z); const posH = toScreenPosition({ getWorldPosition: (v) => v.copy(crackTopPos) });
                 labelL2Start.style.display = 'block'; labelL2Start.style.left = `${posL2Start.x}px`; labelL2Start.style.top = `${posL2Start.y - 20}px`;
                 labelL2End.style.display = 'block'; labelL2End.textContent = `${l2.toFixed(0)} mm`; labelL2End.style.left = `${posL2End.x}px`; labelL2End.style.top = `${posL2End.y - 20}px`;
                 labelHValue.style.display = 'block'; labelHValue.textContent = `h = ${h.toFixed(2)} mm`; labelHValue.style.left = `${posH.x + 20}px`; labelHValue.style.top = `${posH.y + (VISUAL_DEPTH_SCALE * 15)}px`;
             } catch (e) { console.error("Error calculating screen position for labels:", e); if (labelL2Start) labelL2Start.style.display = 'none'; if (labelL2End) labelL2End.style.display = 'none'; if (labelHValue) labelHValue.style.display = 'none'; }
        }
        function onWindowResize() { /* Identical */
            if (!camera || !renderer || !diagramCanvas) return;
            camera.aspect = diagramCanvas.clientWidth / diagramCanvas.clientHeight; camera.updateProjectionMatrix();
            renderer.setSize(diagramCanvas.clientWidth, diagramCanvas.clientHeight);
            console.log("Resized 3D canvas.");
        }
        function animate() { /* Identical */
             requestAnimationFrame(animate);
             if(threeJsInitialized && controls && renderer && scene && camera) {
                 controls.update();
                 renderer.render(scene, camera);
             }
         }

        // --- Main Execution Logic ---
        // Runs after DOM is parsed because script is type="module"
        console.log("Main script execution started.");

        // Get references to essential DOM elements
        form = document.getElementById('crackForm');
        calculateButton = document.getElementById('calculateButton');
        resultDiv = document.getElementById('result');
        diagramSection = document.getElementById('diagramSection');

        // Check if primary elements exist
        if (!form || !calculateButton || !resultDiv) {
            console.error("CRITICAL ERROR: Essential page elements (form, button, or result div) not found. Aborting setup.");
            alert("Page setup error. Essential elements missing.");
        } else {
            // Get elements within resultDiv safely
            resultIcon = resultDiv.querySelector('i');
            resultText = resultDiv.querySelector('span');
            if (!resultIcon || !resultText) {
                 console.error("Error: Result icon or text span not found within result div.");
            }

            console.log("Form, button, and result div found.");
            if (diagramSection) diagramSection.style.display = 'none';

            // Attach listener to the BUTTON click
            calculateButton.addEventListener('click', function(event) {
                console.log("--- Calculate Button Click Handler ---");
                event.preventDefault(); // Prevent default form submission
                console.log("Default action prevented.");

                // Basic HTML5 validation check first
                if (!form.checkValidity()) {
                    console.log("Form invalid via checkValidity(). Reporting...");
                    form.reportValidity(); // Show browser error messages on fields
                    showResult("Please fill all required fields correctly.", true);
                    return; // Stop here if basic validation fails
                }

                 // Proceed with calculation only if form is valid
                 console.log("Form valid, calling calculateCrackDepth...");
                 try {
                     calculateCrackDepth(); // Perform the actual calculation and updates
                 } catch (calcError) {
                     console.error("!!! Unexpected Error during calculateCrackDepth call:", calcError);
                     showResult("Calculation error. Check console.", true);
                 }
                 console.log("--- Button Click Handler Finished ---");

            }); // End addEventListener
            console.log("Click event listener attached to calculateButton.");

            // Initialize Three.js (now safe to call as event listeners are set up)
            initThreeJS();

        } // End if (essential elements found)

        console.log("Main script execution finished.");

    </script>

</body>
</html>
