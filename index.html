    <script type="module">
        // Strict mode
        "use strict";

        // Imports
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Module scope variables ---
        let form, calculateButton, resultDiv, resultIcon, resultText;
        let diagramSection, diagramCanvas;
        let labelL2Start, labelL2End, labelHValue;
        let scene, camera, renderer, controls;
        let concreteBlock, crackPlane, transducerLeft, transducerRight;
        let threeJsInitialized = false;
        const VISUAL_WIDTH_SCALE = 5; const VISUAL_DEPTH_SCALE = 3; const CRACK_PLANE_WIDTH = 0.1;

        // --- Function Definitions ---

        function showResult(message, isError = false) {
            console.log(`DEBUG: showResult called. Message: "${message}", IsError: ${isError}`); // DEBUG
            if (!resultDiv || !resultIcon || !resultText) {
                 console.error("DEBUG: Result elements missing in showResult");
                 return;
            }
            resultText.textContent = message;
            // Ensure diagramSection is defined
            if (!diagramSection) diagramSection = document.getElementById('diagramSection');
             // Ensure labels are defined
             if (!labelL2Start) labelL2Start = document.getElementById('label-l2-start');
             if (!labelL2End) labelL2End = document.getElementById('label-l2-end');
             if (!labelHValue) labelHValue = document.getElementById('label-h-value');

            if (isError) {
                resultDiv.classList.add('error'); resultIcon.className = "fas fa-exclamation-triangle";
                if (diagramSection) diagramSection.style.display = 'none';
                if (labelL2Start) labelL2Start.style.display = 'none';
                if (labelL2End) labelL2End.style.display = 'none';
                if (labelHValue) labelHValue.style.display = 'none';
                 console.log("DEBUG: showResult finished (Error state)."); // DEBUG
            } else {
                resultDiv.classList.remove('error'); resultIcon.className = "fas fa-check-circle";
                 console.log("DEBUG: showResult finished (Success state)."); // DEBUG
            }
        }

        // Calculation Logic with DETAILED LOGGING
        function calculateCrackDepth() {
            console.log("DEBUG: CalculateCrackDepth function STARTED.");
            try {
                const t1Input = document.getElementById('t1'); const l1Input = document.getElementById('l1');
                const t2Input = document.getElementById('t2'); const l2Input = document.getElementById('l2');
                if (!t1Input || !l1Input || !t2Input || !l2Input) {
                    console.error("DEBUG: Input fields missing.");
                    showResult("Error: Input fields missing.", true); return;
                }
                console.log("DEBUG: Input elements found.");

                const t1 = parseFloat(t1Input.value); const l1 = parseFloat(l1Input.value);
                const t2 = parseFloat(t2Input.value); const l2 = parseFloat(l2Input.value);
                console.log(`DEBUG: Parsed Inputs: t1=${t1}, l1=${l1}, t2=${t2}, l2=${l2}`);

                // --- Validation ---
                if (isNaN(t1) || isNaN(l1) || isNaN(t2) || isNaN(l2)) { console.log("DEBUG: Validation FAILED (NaN)."); showResult("Error: All inputs must be valid numbers.", true); return; }
                if (t1 <= 0 || l1 <= 0 || t2 <= 0 || l2 <= 0) { console.log("DEBUG: Validation FAILED (Non-positive)."); showResult("Error: All values must be greater than zero.", true); return; }
                console.log("DEBUG: Input validation PASSED.");

                // --- Calculations ---
                const velocity = l1 / t1;
                console.log(`DEBUG: Calculated Velocity: ${velocity}`);
                if (!isFinite(velocity) || velocity <= 0) { console.log("DEBUG: Velocity calculation FAILED."); showResult("Error: Cannot calculate velocity. Check t1 and l1.", true); return; }

                const t1Scaled = l2 / velocity;
                console.log(`DEBUG: Calculated t1_scaled: ${t1Scaled}`);
                if (!isFinite(t1Scaled)) { console.log("DEBUG: t1Scaled calculation FAILED."); showResult("Error: Cannot calculate scaled time.", true); return; }


                const a = l2 / 2;
                const ratio = t2 / t1Scaled;
                console.log(`DEBUG: Calculated Ratio (t2/t1_scaled): ${ratio}`);

                 if (ratio <= 1 || !isFinite(ratio)) {
                    const detail = isFinite(t1Scaled) ? `(ratio: ${ratio.toFixed(3)})` : '(Invalid t1_scaled)';
                    console.log(`DEBUG: Ratio validation FAILED. ${detail}`);
                    showResult(`Error: t2 must be > calculated direct time ${detail}`, true); return;
                 }
                 console.log("DEBUG: Ratio validation PASSED.");

                const h = a * Math.sqrt(ratio * ratio - 1);
                console.log(`DEBUG: Calculated Depth h: ${h}`);
                if (!isFinite(h)) { console.log("DEBUG: Depth calculation FAILED (NaN/Infinity)."); showResult("Error: Calculation resulted in an invalid depth.", true); return; }

                // --- Success ---
                console.log("DEBUG: Calculation successful. Preparing final output...");
                showResult(`Crack Depth: ${h.toFixed(2)} mm`, false);

                // --- Update 3D ---
                if (threeJsInitialized && diagramSection) {
                    console.log("DEBUG: Attempting to update 3D diagram...");
                    diagramSection.style.display = 'block'; // Show the section
                    try {
                        updateDiagram3D(l2, h);
                        console.log("DEBUG: 3D diagram update function called successfully.");
                    } catch (error) {
                        console.error("!!! DEBUG: Error caught during updateDiagram3D call:", error);
                        showResult(`Crack Depth: ${h.toFixed(2)} mm. (Error updating 3D view)`, false); // Show result but note error
                    }
                } else {
                    console.log("DEBUG: Skipping 3D update (not initialized or section not found).");
                }

            } catch (error) {
                // Catch errors occurring anywhere within the main calculation try block
                console.error("!!! DEBUG: UNEXPECTED Error caught in calculateCrackDepth:", error);
                showResult("An unexpected calculation error occurred. Check console.", true);
            } finally {
                 console.log("DEBUG: CalculateCrackDepth function FINISHED.");
            }
        }


        // --- Three.js Functions (Remain the same, no logging added here for now) ---
        function initThreeJS() { /* ... */ }
        function createInitialObjects() { /* ... */ }
        function updateDiagram3D(l2, h) { /* ... */ }
        function updateOverlayLabels(l2, h) { /* ... */ }
        function onWindowResize() { /* ... */ }
        function animate() { /* ... */ }
        // **NOTE:** For brevity, I've omitted the full Three.js function bodies here.
        // Assume they are exactly the same as in the previous "Final Attempt" code.
        // Copy them back in from that code if needed.
        // <Full Three.js function bodies from previous version go here>
        function initThreeJS() {
            console.log("DEBUG: initThreeJS started.");
            try {
                diagramCanvas = document.getElementById('diagramCanvas');
                if (!diagramCanvas) throw new Error("Canvas 'diagramCanvas' not found!");
                labelL2Start = document.getElementById('label-l2-start'); labelL2End = document.getElementById('label-l2-end'); labelHValue = document.getElementById('label-h-value');
                scene = new THREE.Scene(); scene.background = new THREE.Color(0xf0f4f8);
                const aspectRatio = diagramCanvas.clientWidth / diagramCanvas.clientHeight;
                camera = new THREE.PerspectiveCamera(50, aspectRatio, 0.1, 100); camera.position.set(0, 3, 8); camera.lookAt(0, 0, 0);
                renderer = new THREE.WebGLRenderer({ canvas: diagramCanvas, antialias: true, alpha: true });
                renderer.setSize(diagramCanvas.clientWidth, diagramCanvas.clientHeight); renderer.setPixelRatio(window.devicePixelRatio);
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(5, 10, 7.5); scene.add(directionalLight);
                controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.1; controls.screenSpacePanning = false; controls.target.set(0, 0, 0);
                createInitialObjects(); animate(); window.addEventListener('resize', onWindowResize, false);
                threeJsInitialized = true; console.log("DEBUG: Three.js Initialized OK.");
            } catch (error) { console.error("!!! DEBUG: Three.js Init Failed:", error); threeJsInitialized = false; showResult("Error initializing 3D view.", true); if(diagramSection) diagramSection.style.display = 'none'; }
        }
        function createInitialObjects() {
            const blockGeometry = new THREE.BoxGeometry(VISUAL_WIDTH_SCALE * 1.2, VISUAL_DEPTH_SCALE, VISUAL_DEPTH_SCALE * 0.8); const blockMaterial = new THREE.MeshStandardMaterial({ color: 0xd1d5db, roughness: 0.8 });
            concreteBlock = new THREE.Mesh(blockGeometry, blockMaterial); concreteBlock.position.y = -VISUAL_DEPTH_SCALE / 2; scene.add(concreteBlock);
            const transducerRadius = 0.15; const transducerHeight = 0.1; const transducerGeometry = new THREE.CylinderGeometry(transducerRadius, transducerRadius, transducerHeight, 16); const transducerMaterial = new THREE.MeshStandardMaterial({ color: 0x374151, roughness: 0.5 });
            transducerLeft = new THREE.Mesh(transducerGeometry, transducerMaterial); transducerLeft.position.set(-VISUAL_WIDTH_SCALE / 2, transducerHeight / 2, 0); scene.add(transducerLeft);
            transducerRight = new THREE.Mesh(transducerGeometry, transducerMaterial); transducerRight.position.set(VISUAL_WIDTH_SCALE / 2, transducerHeight / 2, 0); scene.add(transducerRight);
            const crackGeometry = new THREE.PlaneGeometry(CRACK_PLANE_WIDTH, 0.01); const crackMaterial = new THREE.MeshBasicMaterial({ color: 0xef4444, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
            crackPlane = new THREE.Mesh(crackGeometry, crackMaterial); crackPlane.position.set(0, -0.005, 0); scene.add(crackPlane); console.log("DEBUG: Initial 3D objects created.");
        }
        function updateDiagram3D(l2, h) {
            if (!threeJsInitialized || !transducerLeft || !transducerRight || !crackPlane) return;
            const visualL2 = VISUAL_WIDTH_SCALE; transducerLeft.position.x = -visualL2 / 2; transducerRight.position.x = visualL2 / 2;
            const maxExpectedH = l2 > 0 ? l2 : 1; const visualMaxH = VISUAL_DEPTH_SCALE * 0.9; const h_scaled = (h / maxExpectedH) * visualMaxH;
            const finalVisualH = Math.min(Math.max(h_scaled, 0.01), visualMaxH);
            crackPlane.scale.y = finalVisualH / 0.01; crackPlane.position.y = - (finalVisualH / 2);
            updateOverlayLabels(l2, h);
        }
        function updateOverlayLabels(l2, h) {
             if (!renderer || !camera || !labelL2Start || !labelL2End || !labelHValue || !transducerLeft || !transducerRight || !crackPlane) return;
             const canvas = renderer.domElement; const toScreenPosition = (object) => { const vector = new THREE.Vector3(); object.getWorldPosition(vector); vector.project(camera); const x = ((vector.x * 0.5 + 0.5) * canvas.clientWidth); const y = ((-vector.y * 0.5 + 0.5) * canvas.clientHeight); return { x, y }; };
             try {
                 const posL2Start = toScreenPosition(transducerLeft); const posL2End = toScreenPosition(transducerRight);
                 const crackTopPos = new THREE.Vector3(crackPlane.position.x, 0, crackPlane.position.z); const posH = toScreenPosition({ getWorldPosition: (v) => v.copy(crackTopPos) });
                 labelL2Start.style.display = 'block'; labelL2Start.style.left = `${posL2Start.x}px`; labelL2Start.style.top = `${posL2Start.y - 20}px`;
                 labelL2End.style.display = 'block'; labelL2End.textContent = `${l2.toFixed(0)} mm`; labelL2End.style.left = `${posL2End.x}px`; labelL2End.style.top = `${posL2End.y - 20}px`;
                 labelHValue.style.display = 'block'; labelHValue.textContent = `h = ${h.toFixed(2)} mm`; labelHValue.style.left = `${posH.x + 20}px`; labelHValue.style.top = `${posH.y + (VISUAL_DEPTH_SCALE * 15)}px`;
             } catch (e) { console.error("DEBUG: Error calculating label positions:", e); if (labelL2Start) labelL2Start.style.display = 'none'; if (labelL2End) labelL2End.style.display = 'none'; if (labelHValue) labelHValue.style.display = 'none'; }
        }
        function onWindowResize() {
            if (!camera || !renderer || !diagramCanvas) return; camera.aspect = diagramCanvas.clientWidth / diagramCanvas.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(diagramCanvas.clientWidth, diagramCanvas.clientHeight); console.log("DEBUG: Resized.");
        }
        function animate() { requestAnimationFrame(animate); if(threeJsInitialized && controls && renderer && scene && camera) { controls.update(); renderer.render(scene, camera); } }


        // --- Main Execution Logic ---
        console.log("DEBUG: Main script: Starting setup...");
        // Get references ONCE
        form = document.getElementById('crackForm');
        calculateButton = document.getElementById('calculateButton');
        resultDiv = document.getElementById('result');
        diagramSection = document.getElementById('diagramSection');
        resultIcon = resultDiv ? resultDiv.querySelector('i') : null;
        resultText = resultDiv ? resultDiv.querySelector('span') : null;

        if (!form || !calculateButton || !resultDiv || !resultIcon || !resultText) {
            console.error("CRITICAL: Essential elements missing. Aborting.");
            alert("Page Error: Cannot find essential elements (form/button/result).");
        } else {
            console.log("DEBUG: Essential elements found.");
            if (diagramSection) diagramSection.style.display = 'none';

            // Attach listener to the BUTTON click
            calculateButton.addEventListener('click', function(event) {
                console.log("DEBUG: --- Calculate Button Click Handler START ---");
                event.preventDefault();
                console.log("DEBUG: Default action prevented.");

                if (!form.checkValidity()) {
                    console.log("DEBUG: Form invalid (HTML5). Reporting...");
                    form.reportValidity();
                    showResult("Please fill all required fields correctly.", true);
                    console.log("DEBUG: --- Button Click Handler END (Invalid Form) ---");
                    return;
                }

                 console.log("DEBUG: Form valid (HTML5). Calling calculateCrackDepth...");
                 try {
                     calculateCrackDepth(); // Perform the calculation
                 } catch (calcError) {
                     console.error("!!! DEBUG: Unexpected Error during calculateCrackDepth call:", calcError);
                     showResult("Calculation error. Check console.", true);
                 }
                 console.log("DEBUG: --- Button Click Handler END ---");
            });
            console.log("DEBUG: Click listener attached to calculateButton.");

            // Initialize Three.js AFTER setting up the click listener
            initThreeJS();
        }
        console.log("DEBUG: Main script: Setup finished.");

    </script>

    <!-- The rest of the HTML body (container closing div, etc.) -->
     </div> <!-- Closing container div -->
</body>
</html>
